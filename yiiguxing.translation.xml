<application>
  <component name="AppStorage">
    <histories>
      <item value="pursue" />
      <item value="purse" />
      <item value="companion object { @Suppress(&quot;unused&quot;) private const val TAG = &quot;XGimiPresenter&quot; } private var isContinueEnable = true init { initVideoListener() } protected lateinit var videoListener: IVideoPlayerListener /** * 用于刷新标题栏的Disposable */ protected open var titleDisposable: Disposable? = null /** * 用于显示和关闭标题栏做延迟操作的Disposable */ protected open var titleDelayShowDisposable: Disposable? = null protected open var continueDisposable: Disposable? = null protected open var netSpeedDisposable: Disposable? = null private val netSpeedUtils: NetSpeedUtils = NetSpeedUtils() override var isWindow: Boolean = false override fun unbind() { iModel.unbind() super.unbind() } /** * 卡顿检测监听 */ override val stuckCheckListener = object : IStuckCheckPresenter.IStuckCheckListener { override fun retry(times: Int) { when (times) { 1, 2, 6 -&gt; { } 3 -&gt; { val curPos = iView.currentPosition Log.i(&quot;StuckChecker&quot;, &quot;pos:$curPos, retry:$times&quot;) // seekTo((curPos + 2000)) } 4 -&gt; onMediaPlay() 5 -&gt; { iModel.savePlayProgress(iModel.playResource, iView.currentPosition) initAndPlay() } else -&gt; { KLog.e(&quot;StuckChecker&quot;, &quot;视频资源异常&quot;) iView.showToast(&quot;视频资源异常,请重试&quot;) iView.quit() resetRetry() } } } } private fun showTitle(boolean: Boolean, delay: Long = 0) { titleDelayShowDisposable?.dispose() titleDelayShowDisposable = Observable.timer(delay, TimeUnit.MILLISECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe({ iView.showTitle(boolean) }, {}) addDisposable(titleDelayShowDisposable) titleDisposable?.dispose() titleDisposable = Observable.interval(1000, TimeUnit.MILLISECONDS) .observeOn(AndroidSchedulers.mainThread()) .subscribe({ iView.setVideoName(iModel.videoName) iView.setSystemTime(getSystemTime()) }, {}) addDisposable(titleDisposable) } private fun initVideoListener() { videoListener = object : IVideoPlayerListener { override fun onPrepared(totalDuration: Long) { KLog.e(&quot;videoListener&quot;, &quot;onPrepared = $totalDuration&quot;) iModel.totalDuration = totalDuration iModel.isPlayComplete = false iModel.isPlayReady = true KLog.e(TAG, &quot;onPrepared:isPlayReady = ${iModel.isPlayReady}&quot;) KLog.e(TAG, &quot;onPrepared:totalDuration = ${iModel.totalDuration}&quot;) iView.updateSecondProgress(0) iView.onMediaPrepared(totalDuration) if (iModel.videoType == VideoConstant.LIVE_VIDEO) { onMediaPlay() iView.showTitle(true) showTitle(false, ControlCons.HIDE_DELAY) iView.showProgressBarEnable(false) showControlLayout() } else { val lastProgress = iModel.lastProgress KLog.e(&quot;videoListener&quot;, &quot;lastProgress:$lastProgress&quot;) onMediaPlay() if (lastProgress == 0L) { iView.showProgressBarEnable(false) showControlLayout() } else { if (iModel.isUserSwitch) { iModel.isUserSwitch = false return } if (!iModel.isTrySee) { iModel.isBackToBeginning = true isContinueEnable = true } if (checkContinue(lastProgress)) { seekTo(lastProgress) } } } } override fun onComplete() { KLog.e(&quot;videoListener&quot;, &quot;onComplete&quot;) iModel.isPlayComplete = true if (iModel.videoType == VideoConstant.TRY) { closeDisposable() iView.openPayPage() return } progressDisposable?.dispose() val currentPosition = if (iModel.controlPosition == VideoConstant.CONTROL_POSITION) iView.currentPosition else iModel.controlPosition iModel.insertPlayStatus(iModel.playResource, currentPosition, iModel.totalDuration) // 检查是否包含下一集 checkNextVideo(ControlCons.CONTROL_AUTO) } override fun onError(what: Int, extra: Int) { KLog.e(&quot;videoListener&quot;, &quot;onFailure&quot;) iModel.databaseDelete(iModel.playResource) iView.showToast(&quot;${getResourceString(R.string.play_video_exception)}&quot;) iView.quit() } override fun onBufferingUpdate(percent: Int) { KLog.e(&quot;videoListener&quot;, &quot;onBufferingUpdate&quot;) if (!iModel.isPlayComplete &amp;&amp; iModel.isPlayReady) { iView.updateSecondProgress(percent) } } override fun onSeekComplete() { KLog.e(TAG, &quot;onSeekComplete&quot;) isSeekComplete = true noticeSeekComplete() onMediaPlay() iView.showForwardIconEnable(false) iView.showRewindIconEnable(false) // if (!isPause) { // onMediaPlay() // } else { // iView.showPauseViewEnable(true) // } delayCloseControlLayout(ControlCons.HIDE_DELAY) iView.showProgressBarEnable(false) } override fun onInfo(what: Int, extra: Int) { KLog.e(&quot;videoListener&quot;, &quot;onInfo = $what,isPlayComplete = ${iModel.isPlayComplete}&quot;) var bufferStartTime: Long = 0 fun bufferStart() { if (iModel.isPlayComplete) return // 缓冲开始 onBufferStart() bufferStartTime = System.currentTimeMillis() noticeBuffering() // 如果没有显示快进快退图标，则显示加载进度控件 // if (!iView.isShowForwardAndRewind) iView.showProgressBarEnable(true) getNetSpeed() } fun bufferEnd() { netSpeedDisposable?.dispose() if (iModel.isPlayComplete) return // 缓冲结束 onBufferEnd() val curPosition = iView.currentPosition iModel.dataReport(LogConstant.BUFFER, 0, System.currentTimeMillis() - bufferStartTime, curPosition) noticeBufferEnd() if (isContinueEnable) { // 重播是否弹出续播提示 isContinueEnable = if (checkContinue(iModel.lastProgress)) { // 允许小窗模式，则不进行续播弹窗,不消费isContinueEnable if (isWindow) { true } else { // 不允许小窗模式,则进行续播弹窗提示并消费isContinueEnable checkPlayToBegging() false } } else { // 不符合续播弹窗条件,消费isContinueEnable false } } showControlLayout() // 如果快进没有完成，则显示加载进度框 iView.showProgressBarEnable(!isSeekComplete) // 如果是快进中，则不进行后续操作 if (!isSeekComplete) return if (isPause) { iView.showPauseViewEnable(isPause) } onMediaPlay() } fun buffering() { // 正在缓冲 onBuffering() if (iView.isShowProgressBar) { // 刷新缓存速度显示 iView.freshBufferSpeed(extra) } } RxUtils.ui({ when (what) { BufferConstant.BUFFER_START -&gt; bufferStart() BufferConstant.BUFFER_END -&gt; bufferEnd() BufferConstant.BUFFERING -&gt; buffering() BufferConstant.BUFFER_PERCENT -&gt; onBufferPercent() } }) } override fun onVideoSizeChanged(width: Int, height: Int) { KLog.e(TAG, &quot;onVideoSizeChanged&quot;) } } } override fun checkPlayToBegging() { KLog.e(TAG, &quot;checkPlayToBegging:$isContinueEnable&quot;) if (isContinueEnable) { iView.showToast(&quot;自动为您续播 , 按OK键从头播放&quot;) continueDisposable?.dispose() continueDisposable = Observable.timer(3500, TimeUnit.MILLISECONDS) .observeOn(Schedulers.io()) .subscribe { iModel.isBackToBeginning = false } addDisposable(continueDisposable) iModel.isBackToBeginning = true isContinueEnable = false } } override fun onNext(action: Int) { switchEpisodes(action, { if (iModel.playPosition + 1 &gt;= iModel.videoArray.size) { // 如果为单集影片，则不进行没有下一集提示 if (iModel.videoArray.size &gt; 1) { iView.showToast(CommonApp.getInstance().getString(R.string.toast_no_next)) } // 如果是自动播放，则在没有下一集的情况下退出 when (action) { ControlCons.CONTROL_VOICE -&gt; { } ControlCons.CONTROL_AUTO, ControlCons.CONTROL_USER -&gt; quit() } false } else { iModel.savePlayProgress(iModel.playResource, iView.currentPosition) iModel.playPosition++ onSwitchEpisodesDataReporter(action) true } }, { noticePreparing() iView.showToast(CommonApp.getInstance().getString(R.string.toast_playing_next)) }) // 此处如果有后续操作，则重写该方法，调用super } override fun initAndPlay() { KLog.d(TAG, &quot;initAndPlay:${iModel.playPosition},${iModel.playResource}&quot;) if (iModel.playResource == null) { iView.showToast(CommonApp.getInstance().getString(R.string.progress_wait_fail)) iView.quit() return } // 初始化进度控制相关变量 iModel.controlPosition = VideoConstant.CONTROL_POSITION speed = VideoConstant.BASE_SPEED KLog.d(TAG, &quot;iModel.playResource:${Gson().toJson(iModel.playResource)}&quot;) playResource(iModel.playResource!!) } /** * 切换集数 */ protected open fun switchEpisodes(action: Int, exPosition: () -&gt; Boolean, execute: () -&gt; Unit) { KLog.e(TAG, &quot;switchEpisodes:&quot;) // 控制下标 if (!exPosition()) return // 如果是用户手动切换，则设置isUserSwitch为true，如果是自动切换，反之。 iModel.isUserSwitch = action != ControlCons.CONTROL_AUTO iModel.savePlayProgress(iModel.playResource, 0) iView.setSeekBar(0) // 先执行释放资源 //release() /* 如果播放资源链接为空，则1500ms后退出，并不执行后续操作 在iModel中设置nextResource时，进行资源校验 */ if (iModel.playResource == null) { quit() return } execute() initAndPlay() } override fun quit(delay: Long) { noticeStop() iView.showToast(CommonApp.getInstance().getString(R.string.toast_play_complete)) Handler().postDelayed({ iModel.databaseDelete(iModel.playResource) iView.quit() }, delay) } override fun onPrevious(action: Int) { switchEpisodes(action, { if (iModel.playPosition &lt;= 0) { iView.showToast(CommonApp.getInstance().getString(R.string.toast_no_previous)) false } else { iModel.savePlayProgress(iModel.playResource, iView.currentPosition) iModel.playPosition-- onSwitchEpisodesDataReporter(action) true } }, { noticeSwitch() iView.showToast(CommonApp.getInstance().getString(R.string.toast_playing_previous)) }) // 此处如果有后续操作，则重写该方法，调用super } protected open fun onSwitchEpisodesDataReporter(action: Int) { val dataReportAction = when (action) { ControlCons.CONTROL_AUTO -&gt; DataReporterManager.PLAY_AUTO else -&gt; DataReporterManager.PLAY_CLICK } iModel.dataReport(DataReporterManager.OPEN_VIDEO_PLAY, dataReportAction) } override fun playResource(data: DATA, quality: QualityData?) { iModel.isPlayComplete = false KLog.d(TAG, &quot;playResource:videoListener = $videoListener&quot;) iView.registerListener(videoListener) iView.playResource(data, quality) // 通知Launcher历史记录 sendPlayRecord(data) // 显示加载进度条 iView.showProgressBarEnable(true) // 隐藏控制栏 iView.showControlLayoutEnable(false) // LauncherHistoryUtils.sendPlayRecordByCIBN( // data.videoId, data.videoName, data.contentPic, iModel.historyType) } override fun playVideoByIndex(index: Int) { Log.d(&quot;playVideoByIndex&quot;, &quot;index: $index,playPosition: ${iModel.playPosition}&quot;) // 如果当前选择播放集数与正在播放集数是一致的，或指定播放集数不在播放列表中，则不执行后续操作 val position = index - 1 if (iView.isPlaying &amp;&amp; (iModel.playPosition == position || position &lt; 0)) return iModel.playPosition = position if (iModel.playResource == null) { iView.showToast(CommonApp.getInstance().getString(R.string.progress_wait_fail)) iView.quit() return } // 初始化进度控制相关变量 iModel.controlPosition = VideoConstant.CONTROL_POSITION speed = VideoConstant.BASE_SPEED Log.d(&quot;playVideoByIndex&quot;, &quot;index: $index,data${JSON.toJSONString(iModel.playResource)}&quot;) playResource(iModel.playResource!!, iModel.videoQuality.find { it.name == iModel.currentQuality?.name }) } override fun switchVideoQuality(quality: QualityData) { val oldQuality = iModel.videoQuality.find { it.isPlaying } if (oldQuality?.name == quality.name) { return } val newQuality = iModel.videoQuality.find { it.name == quality.name } if (newQuality == null) { KLog.e(TAG, &quot;switchVideoQuality failure | newQuality is not on the QualityList&quot;) return } oldQuality?.isPlaying = false newQuality.isPlaying = true iModel.currentQuality = newQuality if (iModel.playResource == null) { KLog.e(TAG, &quot;switchVideoQuality failure | playResource == null&quot;) return } KLog.d(TAG, &quot;switchVideoQuality newVideoQuality: ${iModel.videoQuality}&quot;) val currentPosition = iView.currentPosition playResource(iModel.playResource!!, newQuality) seekTo(currentPosition) } override fun switchImageMode(data: MenuDataBean.ItemData&lt;*&gt;) { ImageModeUtils.switchImageMode(data.id) } override fun switchImageZoom(data: MenuDataBean.ItemData&lt;*&gt;) { iView.setZoomMode(data.id) } override fun switchPlaySpeed(data: MenuDataBean.ItemData&lt;*&gt;) { iView.switchPlaySpeed(data.id) } override fun onMediaPlay() { safeExecute { KLog.e(TAG, &quot;onMediaPlay:playing = ${iView.isPlaying},isSeekComplete = $isSeekComplete&quot;) if (!iView.isPlaying &amp;&amp; isSeekComplete) { // if (isSeekComplete) { KLog.e(TAG, &quot;onMediaPlay:&quot;) iView.showPauseViewEnable(false) iView.showProgressBarEnable(false) iView.onMediaPlay() // 默认开始播放后即暂停缓冲结束 resetRetry() noticePlaying() } } } override fun onMediaPause() { KLog.d(TAG,&quot;onMediaPause()&quot;) safeExecute { if (iView.isPlaying) { iView.onMediaPause() noticePause() } } } override fun onMediaStop() { KLog.d(TAG,&quot;onMediaStop()&quot;) fun stop() { closeDisposable() //iView.onMediaStop() // iView.release() } KLog.e(TAG, &quot;currentPosition:${iView.currentPosition}&quot;) safeExecute { stop() cancelCheck() } } override fun onBackground() { KLog.d(TAG,&quot;onBackground()&quot;) if (iModel.isPlayReady &amp;&amp; iModel.videoType != VideoConstant.LIVE_VIDEO &amp;&amp; !iModel.isPlayComplete) { iModel.savePlayProgress(iModel.playResource, iView.currentPosition) //退出的时候打个点 sendPlayRecord(iModel.playResource!!) } isContinueEnable = true release() } override fun reset() { KLog.d(TAG,&quot;reset()&quot;) iView.reset() } override fun release() { KLog.d(TAG,&quot;release()&quot;) iView.release() } override fun seekTo(long: Long) { safeExecute { KLog.e(TAG, &quot;seekTo:&quot;) iView.seekTo(long) } } private fun getNetSpeed() { KLog.d(TAG, &quot;getNetSpeed:${netSpeedUtils.speed.toInt()}&quot;) netSpeedDisposable?.dispose() netSpeedDisposable = Observable.interval(0, 1, TimeUnit.SECONDS) .observeOn(AndroidSchedulers.mainThread()) .`as`(AutoDispose.autoDisposable( AndroidLifecycleScopeProvider.from(iView.lifecycleOwner))) .subscribe({ iView.freshBufferSpeed(netSpeedUtils.speed.toInt()) }, {}) addDisposable(netSpeedDisposable) }" />
      <item value="responsible" />
      <item value="We don't turn this method into a no-op if the surface is being replaced with itself // so as to ensure onRenderedFirstFrame callbacks are still called in this case." />
      <item value="Thrown when a non-recoverable playback failure occurs" />
      <item value="album" />
      <item value="set Early Work Completed" />
      <item value="Seminar" />
      <item value="already" />
      <item value="订购" />
      <item value="interactive rebase in progress" />
      <item value="You must edit all merge conflicts and then mark them as resolved using git add" />
      <item value="(use &quot;git rebase --continue&quot; once you are satisfied with your changes)" />
      <item value="(use &quot;git commit --amend&quot; to amend the current commit)" />
      <item value="You are currently editing a commit" />
      <item value="remaining" />
      <item value="interval" />
      <item value="thereafter" />
      <item value="INSTALL FAILED UPDATE INCOMPATIBLE" />
      <item value="expire" />
      <item value="Bought" />
      <item value="event Update Ji Num" />
      <item value="Used to update the selection subscript that is currently playing when player switches selections" />
      <item value="Entity" />
      <item value="Calls the specified function [block] with `this` value as its receiver and returns `this` value." />
      <item value="Translate" />
      <item value="set Zoom Mode" />
      <item value="up Date Chart View" />
      <item value="include Font Padding" />
      <item value="duplicate Parent State" />
      <item value="Space" />
      <item value="Extra" />
      <item value="simulator" />
      <item value="revert" />
      <item value="Restrict usage to code within the same group of libraries. * This corresponds to the gradle group ID." />
      <item value="LIBRARY GROUP" />
      <item value="Restrict To" />
      <item value="TRANSPARENT" />
      <item value="shuffle" />
      <item value="Randomly shuffles elements in this mutable list." />
      <item value="he index at which the items should be inserted" />
      <item value="Returns an array containing the specified elements" />
      <item value="An action contains one or two lines of text, an optional image and an optional id. It may also * be invoked by one or more keycodes." />
      <item value="Spinner Fragment" />
      <item value="Spinner" />
      <item value="fast Lane" />
      <item value="brand" />
      <item value="Uses a lookup table for the Bezier curve from (0,0) to (1,1) with control points" />
      <item value="fast out linear in" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="489" />
        <entry key="ENGLISH" value="479" />
        <entry key="CHINESE_TRADITIONAL" value="7" />
        <entry key="ESTONIAN" value="1" />
        <entry key="POLISH" value="1" />
        <entry key="BOSNIAN" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="MALAY" value="3" />
        <entry key="NORWEGIAN" value="2" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="ESPERANTO" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="HINDI" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="primaryFontFamily" value="Yu Gothic UI" />
    <option name="translator" value="ai.youdao" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6953e2b0635b37a0" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>