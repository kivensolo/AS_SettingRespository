<application>
  <component name="AppStorage">
    <histories>
      <item value="shift Live Mutlicastl Url" />
      <item value="SHORT" />
      <item value="reuses" />
      <item value="thread" />
      <item value="Returns a pseudo-random double {@code n}, where {@code n &gt;= 0.0 &amp;&amp; n &lt; 1.0}. * This method reuses a single instance of {@link java.util.Random}. * This method is thread-safe because access to the {@code Random} is synchronized, * but this harms scalability. Applications may find a performance benefit from * allocating a {@code Random} for each of their threads. * * @return a pseudo-random number." />
      <item value="recover Player" />
      <item value="add Carousel Error" />
      <item value="Carousel" />
      <item value="seamless" />
      <item value="It is useful when ViewModel observes some data and you need to clear this subscription to * prevent a leak of this ViewModel." />
      <item value="This method will be called when this ViewModel is no longer used and will be destroyed" />
      <item value="Since clear() is final" />
      <item value="Bag Of Tags" />
      <item value="m Bag Of Tags" />
      <item value="because it can lose values on old apis" />
      <item value="Can't use ConcurrentHashMap, because it can lose values on old apis (see b/37042460)" />
      <item value="Each Fragment can acquire the ViewModel using the same key via their Activity. This allows * communication between Fragments in a de-coupled fashion such that they never need to talk to * the other Fragment directly." />
      <item value="ViewModels can also be used as a communication layer between different Fragments of an Activity." />
      <item value="Typical usage from an Activity standpoint would be:" />
      <item value="ViewModel's only responsibility is to manage the data for the UI. It &lt;b&gt;should never&lt;/b&gt; access * your view hierarchy or hold a reference back to the Activity or the Fragment." />
      <item value="You can also use any observability construct from you favorite framework." />
      <item value="The purpose of the ViewModel is to acquire and keep the information that is necessary for an * Activity or a Fragment" />
      <item value="In other words, this means that a ViewModel will not be destroyed if its owner is destroyed for a * configuration change (e.g. rotation). The new instance of the owner will just re-connected to the * existing ViewModel." />
      <item value="A ViewModel is always created in association with a scope (an fragment or an activity) and will * be retained as long as the scope is alive. E.g. if it is an Activity, until it is * finished." />
      <item value="responsible for preparing and managing the data" />
      <item value="ViewModel is a class that is responsible for preparing and managing the data for * an {@link android.app.Activity Activity} or a {@link androidx.fragment.app.Fragment Fragment}." />
      <item value="An implementation of [Lazy] used by [androidx.fragment.app.Fragment.viewModels] and * [androidx.activity.ComponentActivity.viewmodels]. * * [storeProducer] is a lambda that will be called during initialization, [VM] will be created * in the scope of returned [ViewModelStore]. * * [factoryProducer] is a lambda that will be called during initialization, * returned [ViewModelProvider.Factory] will be used for creation of [VM]" />
      <item value="Closeable Coroutine Scope" />
      <item value="Absent" />
      <item value="Lifecycle Registry" />
      <item value="Accumulates entries of this context starting with [initial] value and applying [operation] * from left to right to current accumulator value and each element of this context." />
      <item value="Persistent context for the coroutine. It is an indexed set of [Element] instances. * An indexed set is a mix between a set and a map. * Every element in this set has a unique [Key]. */" />
      <item value="Suspends coroutine similar to [suspendCoroutine], but provide an implementation of [CancellableContinuation] to * the [block]. This function throws [CancellationException] if the coroutine is cancelled or completed while suspended." />
      <item value="coroutine" />
      <item value="NOTE: Before version 1.1.0 the following invocation was inlined here, so invocation of this // method indicates that the code was compiled by kotlinx.coroutines &lt; 1.1.0 // cancellable.initCancellability()" />
      <item value="Interface definition of a callback to be invoked when a * timed text is available for display." />
      <item value="ad Presenter Id" />
      <item value="Presenter" />
      <item value="DSL object for configuring APK packaging options." />
      <item value="pattern the pattern, as packaged in the APK" />
      <item value="Strip" />
      <item value="Adds a doNotStrip pattern." />
      <item value="do Not Strip" />
      <item value="target Compatibility" />
      <item value="source Compatibility" />
      <item value="Failed resolution of" />
      <item value="Can {@code c} be assigned to this class? For example, String can be assigned to Object * (by an upcast), however, an Object cannot be assigned to a String as a potentially exception * throwing downcast would be necessary. Similarly for interfaces, a class that implements (or * an interface that extends) another can be assigned to its parent, but not vice-versa. All * Classes may assign to themselves. Classes for primitive types may not assign to each other." />
      <item value="Indicates if the class should be resolved after loading. This * parameter is ignored on the Android reference implementation; * classes are not resolved." />
      <item value="resolve" />
      <item value="Loads classes and resources from a repository. One or more class loaders are * installed at runtime. These are consulted whenever the runtime system needs a * specific class that is not yet available in-memory. Typically, class loaders * are grouped into a tree where child class loaders delegate all requests to * parent class loaders. Only if the parent class loader cannot satisfy the * request, the child class loader itself tries to handle it. * &lt;p&gt; * {@code ClassLoader} is an abstract class that implements the common * infrastructure required by all class loaders. Android provides several * concrete implementations of the class, with * {@link dalvik.system.PathClassLoader} being the one typically used. Other * applications may implement subclasses of {@code ClassLoader} to provide * special ways for loading classes." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="417" />
        <entry key="ENGLISH" value="516" />
        <entry key="POLISH" value="1" />
        <entry key="DANISH" value="5" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="FILIPINO" value="1" />
        <entry key="MALAY" value="2" />
        <entry key="TURKISH" value="3" />
        <entry key="SPANISH" value="2" />
        <entry key="HINDI" value="1" />
        <entry key="INDONESIAN" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="autoPlayTTS" value="true" />
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="useTranslateGoogleCom" value="true" />
      </google-translate>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="ai.youdao" />
    <option name="ttsSource" value="TRANSLATION" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6953e2b0635b37a0" />
        <option name="primaryLanguage" value="ENGLISH" />
      </youdao-translate>
    </option>
  </component>
</application>